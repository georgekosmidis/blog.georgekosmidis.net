<p>There are some problems so difficult, so incredibly vast, that even if every supercomputer in the world worked on the problem, it would still take longer than the lifetime of the universe to solve!<br />
<br />
The phrase above, found in Microsoft Docs, captures today&#8217;s problems with our regular computers and as a result the limitations we face in our every day lives. Numerous problems in environment, health, agriculture and many other fields have a solution lost in a vast ocean of possible answers that need to be tested one by one for correctness.</p>
<p>Enters Quantum Computing!</p>
<h2>What is Quantum Computing</h2>
<p>Quantum computing is the use of quantum-mechanical phenomena such as superposition and entanglement to perform computations. These quantum-mechanical phenomena are described by quantum physics as the behavior of atoms and fundamental particles, like electrons and photons. A quantum computer operates by controlling the behavior of these particles, but in a way that is completely different from regular computers. Quantum computers are vastly more capable of solving problems like integer factorization (which underlies RSA encryption), but since they are notoriously difficult to build and program they are crippled by errors in such a degree, that their operation falls apart before any nontrivial program has a chance to complete.</p>
<h3>What is Quantum Superposition</h3>
<p>Imagine two colliding waves in the sea; sometimes they perfectly add to make a bigger wave, sometimes they completely cancel each other out, but often it’s just a combination of both somewhere in between. This constructive or destructive interference of waves is known as superposition in classical physics.</p>
<p>In Quantum mechanics though, superposition can be a bit weirder!</p>
<p><img src="media\800px-Schrodingers_cat.svg.png" alt="A cat, with a Geiger counter, and a bit of poison in a sealed box. Quantum mechanics says that after a while, the cat is both alive and dead. A person looking into the box will either find the cat alive or dead, however it is assumed to be both alive and dead before you look into the box." /></p>
<p>Particles that exist in different states (for example in different positions or moving at different speeds, etc) are thought of as existing across all the possible states at the same time! Yes, a particle in superposition can exist in two places at the same time and/or move at different speeds simultaneously. This &#8220;unnatural&#8221; state of matter, practically impossible for a human brain to comprehend, it’s one of the weirdest realities of quantum physics.</p>
<blockquote><p>The famous thought experiment, <a href="https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat" target="_blank" rel="noopener noreferrer">Schrödinger&#8217;s cat</a>, was an attempt to illustrate the problems of <a href="https://en.wikipedia.org/wiki/Copenhagen_interpretation" target="_blank" rel="noopener noreferrer">Copenhagen interpretation</a> of quantum mechanics by applying quantum mechanics to everyday objects. <a href="https://en.wikipedia.org/wiki/Copenhagen_interpretation" target="_blank" rel="noopener noreferrer">Copenhagen interpretation</a>, devised somewhere around 1926, was stating that physical systems, in general, do not have a state until measured.</p></blockquote>
<p>However, this weird behavior becomes human-friendly once a measurement of a particle is made; when for example we check its position, no matter how we checked it, the superposition is lost and the particle exists in one known state.</p>
<h3>What is Quantum entanglement</h3>
<p>Quantum entanglement that Einstein described as &#8220;spooky action over distance&#8221;, is a relationship between fundamental particle properties that persist over distance without requiring transmission of information.</p>
<p><img src="media\EntanglementGloves_OBrien_1K.gif" alt="JAMES O'BRIEN FOR QUANTA MAGAZINE" /></p>
<p>Imagine for example, that we put each member of a pair of gloves in boxes (somehow without seeing them) and mail one of them to the opposite side of the earth. Whoever is the recipient should be able, by looking inside her/his box, to determine the properties of the glove that we still have with us in our box. If she/he states &#8220;it&#8217;s blue&#8221; and we open our box our glove will be blue. Simple and not that spooky at all, right? But what about, if the recipient throws the box in green paint affecting the glove&#8217;s color. Will that make my glove change color too? In the particle world, yes. My glove will instantly be green&#8230;!</p>
<p>In other words, measurements of physical properties such as position, momentum, spin, and polarization performed on entangled particles are found to be perfectly correlated, even when the particles are separated by a large distance. Measurements on one particle, affect the entangled system as a whole.</p>
<h2>Quantum programming with Q#</h2>
<p>Quantum programming is the process of assembling sequences of instructions, called quantum programs, that are capable of running on a quantum computer. Quantum programming languages help express quantum algorithms using high-level constructs. High-end programming languages, like Q#, use Quantum software development kits, that provide the means to simulate a quantum environment.</p>
<h3>Hello Quantum World!</h3>
<p>Q# is built to play well with .NET languages such as C# and F#; we just need to install the Quantum Development Kit! In order to do so we need to download and install this Visual Studio Extension: <a href="https://marketplace.visualstudio.com/items?itemName=quantum.DevKit" target="_blank" rel="noopener noreferrer">https://marketplace.visualstudio.com/items?itemName=quantum.DevKit</a>.</p>
<p>When the installation is completed, we can start Visual Studio (it has to be v16.3+) and perform the following steps to create a new Q# application:</p>
<ul>
<li>Start Visual Studio (v16.3+)</li>
<li>Click on &#8220;Create a new project&#8221;</li>
<li>Type &#8220;Q#&#8221; in the search box</li>
<li>Select <strong>Q# Application</strong></li>
<li>Select <strong>Next</strong></li>
<li>Choose a name and location for your application</li>
<li>Make sure that &#8220;place project and solution in same directory&#8221; is <strong>unchecked</strong></li>
<li>Select <strong>Create</strong></li>
</ul>
<p>And that&#8217;s it! We can now run our app and get the familiar greetings:<br />
<img src="media\quantum_hello_world.png" alt="Hello quantum world!" /></p>
<h3>Randomly select an atom in the Universe</h3>
<p>That is, if all atoms in the universe had an index! What we really going to create is a random number generator with an upper limit bigger than the number of the atoms in the universe. This, not so impressive feat, will perfectly demonstrate the very basics of working with <code>Qubits</code>. This is just a blog post after all, not the <a href="https://docs.microsoft.com/en-us/quantum/" rel="noopener noreferrer" target="_blank">full documentation</a>! </p>
<blockquote><p>The <code>Int</code> in Q# is a 64-bit signed integer, where <code>BigInt</code> is a signed integer of arbitrary size and it&#8217;s based on <code><a href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger" rel="noopener noreferrer" target="_blank">BigInteger</a></code>. Read more about the <a href="https://docs.microsoft.com/en-us/quantum/language/type-model" rel="noopener noreferrer" target="_blank">The Type Model</a>. </p></blockquote>
<p>The most interesting type in Q#, the <code>Qubit</code>, upgrades the bit we know to mythical proportions! Where classical bits hold a single binary value such as 0 or 1, the state of a qubit can be in a <em>superposition</em> of 0 and 1! Conceptually, a qubit can be thought of as a direction in space (also known as a vector), where a qubit can be in any of the possible directions. The two classical states are the two directions on one axes (e.g. x&#8217;x); representing 100% chance of measuring 0 and 100% chance of measuring 1. This representation is also more formally visualized by the <a href="https://en.wikipedia.org/wiki/Bloch_sphere" rel="noopener noreferrer" target="_blank">bloch sphere</a>.</p>
<p>As a first step, let&#8217;s try to allocate a qubit, set it to superposition and then measure the result. This will give us, after the measurement, either 100% of the times 1 or 100% of the times 0; while in superposition though it has exactly 50% chances of being either 0 or 1:</p>
<p><pre><code class="language-csharp">operation GetRandomResult() : Result {
    using (q = Qubit())  {                // Allocate a qubit.
        H(q);                             // Hadamard operation; put the qubit to superposition. It now has a 50% chance of being 0 or 1.
        return MResetZ(q);                // Measure the qubit value in the Z basis, and reset it to the standard basis state |0〉 after;
                                          //  MResetX(q) and MResetY(q) do the same for X and Y basis.
    }
}</code></pre></p>
<blockquote><p>An <code>operation</code> is for quantum operations in quantum data, where a <code>function</code> modified classical data. Learn how to work with them in the <a href="https://docs.microsoft.com/en-us/quantum/techniques/operations-and-functions" rel="noopener noreferrer" target="_blank">Q# Operations and Functions</a> section of the documentation.</p></blockquote>
<blockquote><p><code><a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.measurement.mresetz" rel="noopener noreferrer" target="_blank">MResetZ</a></code> measures a single qubit in the Z basis, and resets it to the standard basis state |0〉 following the measurement. Similar operations are the <code><a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.measurement.mresetx" rel="noopener noreferrer" target="_blank">MResetX</a></code> and <code><a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.measurement.mresety" rel="noopener noreferrer" target="_blank">MResetY</a></code>. All the measurement operations are contained in the <a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.measurement" rel="noopener noreferrer" target="_blank">Microsoft.Quantum.Measurement</a> Q# library.</p></blockquote>
<p>Since we are talking about 0s and 1s, we need a way to find how many bits represent the max limit requested (for us the number of atoms in the universe). Thankfully, the library <a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.math" rel="noopener noreferrer" target="_blank">Microsoft.Quantum.Math</a> contains a function named <code><a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.math.bitsizel" rel="noopener noreferrer" target="_blank">BitSizeL</a></code> which does exactly that for signed integers of arbitrary size (<code><a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.math.bitsizei" rel="noopener noreferrer" target="_blank">BitSizeI</a></code> does it for <code>Int</code>). We then need a loop to add to an array of <code>Result</code>s the <code>Result</code> returned by the <code>GetRandomResult()</code> method:</p>
<p><pre><code class="language-csharp">mutable bits = new Result[0];               //This is how to declare a mutable variable
let bitSize = BitSizeL(max);                //This is how to declare an immutable variable

for (_ in 1..bitSize) {                     //Loop
    let result = GetRandomResult();         //Get the result of GetRandomResult() into the the result variable
    set bits += [result];                   //Update the array bits, adding at the end the current result
}</code></pre></p>
<p>Almost there! We just need to convert this array of <code>Result</code> to a <code>BigInt</code>. We can do that by first converting the array of <code>Result</code> to an array of <code>bool,</code> and then the array of <code>bool</code> to <code>BigInt</code>:</p>
<p><pre><code class="language-csharp">let randomNumber = BoolArrayAsBigInt(ResultArrayAsBoolArray(bits));</code></pre></p>
<blockquote><p>All supported conversions are in the <a href="https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.convert" rel="noopener noreferrer" target="_blank">Microsoft.Quantum.Convert</a> Q# Library.</p></blockquote>
<p>There is a problem though! The number of bits that can represent the number requested as <code>max</code> can potentially represent an even bigger number! To compensate for this possible error we can conditionally recurse until we find the correct one:</p>
<p><pre><code class="language-csharp">return randomNumber &gt; max
               ? SampleRandomNumberInRange(max)
               | randomNumber;</code></pre></p>
<p>And finally done! Follows the entire Q# program that returns a really big random number:</p>
<p><pre><code class="language-csharp">namespace Quantum.RandomNumber {

    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Measurement;
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;

    @EntryPoint()
    operation Main () : BigInt  {
        let max = PowL(10L, 80);                        
        Message($"The lucky atom is number ");
        return Generate(max);   
    }
    
    operation Generate(max : BigInt ) : BigInt  {
        mutable bits = new Result[0];                                   //This is how to declare a mutable variable
        let bitSize = BitSizeL(max);                                    //This is how to declare an immutable variable

        for (_ in 1..bitSize) {                                         //Loop
            let result = GetRandomResult();                             //Get the result of GetRandomResult() into the the result variable
            set bits += [result];                                       //Update the array bits, adding at the end the current result
        }

        let sample = BoolArrayAsBigInt(ResultArrayAsBoolArray(bits));   // Convert to BigInt

        return sample &gt; max                                             //Check and return if sample is less or equal to max
               ? Generate(max)
               | sample;
    }


    operation GetRandomResult() : Result {
        using (q = Qubit())  {                                          // Allocate a qubit.
            H(q);                                                       // Hadamard operation; put the qubit to superposition. It now has a 50% chance of being 0 or 1.
            return MResetZ(q);                                          // Measure the qubit value in the Z basis, and reset it to the standard basis state |0〉 after;
                                                                        //  MResetX(q) and MResetY(q) do the same for X and Y basis.
        }
    }
}
</code></pre></p>
<p>Happy coding!</p>
<blockquote><p>Q# works very well with C#, so it is easy to create a Q# Library and use that library from C# (or F#). An example of this interoperability is the <a href="https://github.com/georgekosmidis/Quantum.RandomNumber" rel="noopener noreferrer" target="_blank">Quantum.RandomNumber</a> solution in my <a href="https://github.com/georgekosmidis/Quantum.RandomNumber" rel="noopener noreferrer" target="_blank">GitHub account!</a>. </p></blockquote>
<h2>Further reading</h2>
<p>There are many resources already available that can help you start your journey in the Quantum World. <a href="https://docs.microsoft.com/en-us/quantum/intro-to-katas">Quantum Katas</a> is a good start to learn by doing, so is the <a href="https://docs.microsoft.com/en-us/samples/microsoft/quantum/quantum-teleportation/" rel="noopener noreferrer" target="_blank">Quantum Teleportation Sample</a> for example can help you understand the quantum entanglement, a way of moving a quantum state from one location to another without having to move physical particle(s) along with it. The entry point for all possible resources is the <a href="https://docs.microsoft.com/en-us/quantum/intro-to-katas" rel="noopener noreferrer" target="_blank">Microsoft Quantum Documentation</a>.</p>
<h2>Conclusion</h2>
<p>Physicists have been talking about the power of quantum computing for over 30 years, but the question have always been: will it ever do something useful? Google answered that question just a few months ago, in late 2019, with the <a href="https://www.nature.com/articles/s41586-019-1666-5" rel="noopener noreferrer" target="_blank">Quantum Supremacy experiment</a> that successfully performed a computation in 200 seconds that would otherwise need 10000 years in the faster supercomputer available today! Quantum computing will massively change our lives in so many fields the next years, that it is easily comparable with the invention of the first transistor that led to the 3rd Industrial Revolution, the Digital Revolution. When the first computers appeared, nobody believed that there is going to be a smart phone that will hold more computational power than all the computers of the era combined and we could have that power in our pockets&#8230;!</p><p>The post <a href="https://blog.georgekosmidis.net/quantum-computing-basics-with-q-the-superposition-of-a-qubit/">Quantum Computing basics with Q# – The superposition of a qubit</a> first appeared on <a href="https://blog.georgekosmidis.net">George Kosmidis</a>.</p>